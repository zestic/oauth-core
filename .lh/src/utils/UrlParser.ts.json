{
    "sourceFile": "src/utils/UrlParser.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1752827508523,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752831174416,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -66,13 +66,13 @@\n    * Convert URLSearchParams to a plain object\n    */\n   static toObject(params: URLSearchParams): Record<string, string> {\n     const result: Record<string, string> = {};\n-    \n-    for (const [key, value] of params.entries()) {\n+\n+    params.forEach((value, key) => {\n       result[key] = value;\n-    }\n-    \n+    });\n+\n     return result;\n   }\n \n   /**\n"
                },
                {
                    "date": 1752831200958,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -123,17 +123,17 @@\n    */\n   static sanitizeForLogging(params: URLSearchParams): Record<string, string> {\n     const sensitiveKeys = ['code', 'token', 'magic_link_token', 'access_token', 'refresh_token'];\n     const result: Record<string, string> = {};\n-    \n-    for (const [key, value] of params.entries()) {\n+\n+    params.forEach((value, key) => {\n       if (sensitiveKeys.includes(key)) {\n         result[key] = '[REDACTED]';\n       } else {\n         result[key] = value;\n       }\n-    }\n-    \n+    });\n+\n     return result;\n   }\n \n   /**\n"
                },
                {
                    "date": 1752831224732,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -140,14 +140,14 @@\n    * Merge multiple URLSearchParams objects\n    */\n   static merge(...paramSets: URLSearchParams[]): URLSearchParams {\n     const result = new URLSearchParams();\n-    \n+\n     for (const params of paramSets) {\n-      for (const [key, value] of params.entries()) {\n+      params.forEach((value, key) => {\n         result.set(key, value);\n-      }\n+      });\n     }\n-    \n+\n     return result;\n   }\n }\n"
                }
            ],
            "date": 1752827508523,
            "name": "Commit-0",
            "content": "/**\n * URL parameter parsing utilities for OAuth callbacks\n */\n\nexport class UrlParser {\n  /**\n   * Parse URL search parameters from a URL string or URLSearchParams\n   */\n  static parseParams(input: string | URLSearchParams): URLSearchParams {\n    if (input instanceof URLSearchParams) {\n      return input;\n    }\n\n    // Handle full URLs\n    if (input.includes('://')) {\n      const url = new URL(input);\n      return url.searchParams;\n    }\n\n    // Handle query strings (with or without leading ?)\n    const queryString = input.startsWith('?') ? input.slice(1) : input;\n    return new URLSearchParams(queryString);\n  }\n\n  /**\n   * Extract specific parameters from URLSearchParams\n   */\n  static extractParams(params: URLSearchParams, keys: string[]): Record<string, string | undefined> {\n    const result: Record<string, string | undefined> = {};\n    \n    for (const key of keys) {\n      result[key] = params.get(key) ?? undefined;\n    }\n    \n    return result;\n  }\n\n  /**\n   * Check if required parameters are present\n   */\n  static hasRequiredParams(params: URLSearchParams, requiredKeys: string[]): boolean {\n    return requiredKeys.every(key => params.has(key));\n  }\n\n  /**\n   * Check if any of the specified parameters are present\n   */\n  static hasAnyParams(params: URLSearchParams, keys: string[]): boolean {\n    return keys.some(key => params.has(key));\n  }\n\n  /**\n   * Get the first non-null parameter value from a list of possible keys\n   */\n  static getFirstParam(params: URLSearchParams, keys: string[]): string | null {\n    for (const key of keys) {\n      const value = params.get(key);\n      if (value !== null) {\n        return value;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Convert URLSearchParams to a plain object\n   */\n  static toObject(params: URLSearchParams): Record<string, string> {\n    const result: Record<string, string> = {};\n    \n    for (const [key, value] of params.entries()) {\n      result[key] = value;\n    }\n    \n    return result;\n  }\n\n  /**\n   * Create URLSearchParams from an object\n   */\n  static fromObject(obj: Record<string, string | number | boolean | undefined | null>): URLSearchParams {\n    const params = new URLSearchParams();\n    \n    for (const [key, value] of Object.entries(obj)) {\n      if (value !== undefined && value !== null) {\n        params.set(key, String(value));\n      }\n    }\n    \n    return params;\n  }\n\n  /**\n   * Validate that a parameter matches expected format\n   */\n  static validateParam(params: URLSearchParams, key: string, validator: (value: string) => boolean): boolean {\n    const value = params.get(key);\n    return value !== null && validator(value);\n  }\n\n  /**\n   * Extract OAuth error information from parameters\n   */\n  static extractOAuthError(params: URLSearchParams): { error?: string; errorDescription?: string } {\n    const error = params.get('error');\n    const errorDescription = params.get('error_description');\n\n    return {\n      ...(error && { error }),\n      ...(errorDescription && { errorDescription }),\n    };\n  }\n\n  /**\n   * Check if parameters contain OAuth error\n   */\n  static hasOAuthError(params: URLSearchParams): boolean {\n    return params.has('error');\n  }\n\n  /**\n   * Sanitize parameters by removing sensitive information for logging\n   */\n  static sanitizeForLogging(params: URLSearchParams): Record<string, string> {\n    const sensitiveKeys = ['code', 'token', 'magic_link_token', 'access_token', 'refresh_token'];\n    const result: Record<string, string> = {};\n    \n    for (const [key, value] of params.entries()) {\n      if (sensitiveKeys.includes(key)) {\n        result[key] = '[REDACTED]';\n      } else {\n        result[key] = value;\n      }\n    }\n    \n    return result;\n  }\n\n  /**\n   * Merge multiple URLSearchParams objects\n   */\n  static merge(...paramSets: URLSearchParams[]): URLSearchParams {\n    const result = new URLSearchParams();\n    \n    for (const params of paramSets) {\n      for (const [key, value] of params.entries()) {\n        result.set(key, value);\n      }\n    }\n    \n    return result;\n  }\n}\n"
        }
    ]
}