{
    "sourceFile": "src/core/TokenManager.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1752830459333,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752830542333,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -193,9 +193,9 @@\n \n     } catch (error) {\n       throw ErrorHandler.createError(\n         'Failed to store tokens',\n-        'NETWORK_ERROR',\n+        OAUTH_ERROR_CODES.NETWORK_ERROR,\n         error instanceof Error ? error : new Error(String(error))\n       );\n     }\n   }\n"
                }
            ],
            "date": 1752830459333,
            "name": "Commit-0",
            "content": "/**\n * Token exchange and management\n */\n\nimport {\n  HttpAdapter,\n  TokenExchangeRequest,\n  TokenResponse,\n  OAuthResult,\n  OAuthConfig,\n  StorageAdapter,\n  OAUTH_ERROR_CODES\n} from '../types/OAuthTypes';\nimport { ErrorHandler } from '../utils/ErrorHandler';\n\nexport class TokenManager {\n  private static readonly STORAGE_KEYS = {\n    ACCESS_TOKEN: 'access_token',\n    REFRESH_TOKEN: 'refresh_token',\n    TOKEN_EXPIRY: 'token_expiry',\n    TOKEN_TYPE: 'token_type',\n  };\n\n  constructor(\n    private httpAdapter: HttpAdapter,\n    private storageAdapter: StorageAdapter\n  ) {}\n\n  /**\n   * Exchange authorization code for tokens\n   */\n  async exchangeAuthorizationCode(\n    code: string,\n    codeVerifier: string,\n    config: OAuthConfig\n  ): Promise<OAuthResult> {\n    const request: TokenExchangeRequest = {\n      grantType: 'authorization_code',\n      code,\n      redirectUri: config.redirectUri,\n      codeVerifier,\n      clientId: config.clientId,\n    };\n\n    return this.performTokenExchange(request, config);\n  }\n\n  /**\n   * Exchange magic link token for OAuth tokens\n   */\n  async exchangeMagicLinkToken(\n    token: string,\n    config: OAuthConfig,\n    additionalParams?: Record<string, string>\n  ): Promise<OAuthResult> {\n    const request: TokenExchangeRequest = {\n      grantType: 'magic_link',\n      token,\n      clientId: config.clientId,\n      ...additionalParams,\n    };\n\n    return this.performTokenExchange(request, config);\n  }\n\n  /**\n   * Refresh access token using refresh token\n   */\n  async refreshToken(refreshToken: string, config: OAuthConfig): Promise<OAuthResult> {\n    const request: TokenExchangeRequest = {\n      grantType: 'refresh_token',\n      token: refreshToken,\n      clientId: config.clientId,\n    };\n\n    return this.performTokenExchange(request, config);\n  }\n\n  /**\n   * Perform the actual token exchange HTTP request\n   */\n  private async performTokenExchange(\n    request: TokenExchangeRequest,\n    config: OAuthConfig\n  ): Promise<OAuthResult> {\n    try {\n      const requestBody = this.buildTokenRequestBody(request);\n      \n      const response = await this.httpAdapter.post(\n        config.endpoints.token,\n        requestBody,\n        {\n          'Content-Type': 'application/x-www-form-urlencoded',\n          'Accept': 'application/json',\n        }\n      );\n\n      if (response.status >= 400) {\n        throw ErrorHandler.handleTokenExchangeError(\n          new Error(`HTTP ${response.status}`),\n          response.data\n        );\n      }\n\n      const tokenResponse = response.data as TokenResponse;\n      \n      // Store tokens\n      await this.storeTokens(tokenResponse);\n\n      return {\n        success: true,\n        accessToken: tokenResponse.access_token,\n        refreshToken: tokenResponse.refresh_token,\n        expiresIn: tokenResponse.expires_in,\n      };\n\n    } catch (error) {\n      if (ErrorHandler.isOAuthError(error)) {\n        throw error;\n      }\n\n      throw ErrorHandler.handleTokenExchangeError(\n        error instanceof Error ? error : new Error(String(error))\n      );\n    }\n  }\n\n  /**\n   * Build the request body for token exchange\n   */\n  private buildTokenRequestBody(request: TokenExchangeRequest): Record<string, string> {\n    const body: Record<string, string> = {\n      grant_type: request.grantType,\n      client_id: request.clientId,\n    };\n\n    if (request.code) {\n      body.code = request.code;\n    }\n\n    if (request.redirectUri) {\n      body.redirect_uri = request.redirectUri;\n    }\n\n    if (request.codeVerifier) {\n      body.code_verifier = request.codeVerifier;\n    }\n\n    if (request.token) {\n      if (request.grantType === 'refresh_token') {\n        body.refresh_token = request.token;\n      } else {\n        body.token = request.token;\n      }\n    }\n\n    if (request.state) {\n      body.state = request.state;\n    }\n\n    return body;\n  }\n\n  /**\n   * Store tokens in storage\n   */\n  async storeTokens(tokenResponse: TokenResponse): Promise<void> {\n    try {\n      await this.storageAdapter.setItem(\n        TokenManager.STORAGE_KEYS.ACCESS_TOKEN,\n        tokenResponse.access_token\n      );\n\n      if (tokenResponse.refresh_token) {\n        await this.storageAdapter.setItem(\n          TokenManager.STORAGE_KEYS.REFRESH_TOKEN,\n          tokenResponse.refresh_token\n        );\n      }\n\n      if (tokenResponse.expires_in) {\n        const expiryTime = Date.now() + (tokenResponse.expires_in * 1000);\n        await this.storageAdapter.setItem(\n          TokenManager.STORAGE_KEYS.TOKEN_EXPIRY,\n          expiryTime.toString()\n        );\n      }\n\n      await this.storageAdapter.setItem(\n        TokenManager.STORAGE_KEYS.TOKEN_TYPE,\n        tokenResponse.token_type || 'Bearer'\n      );\n\n    } catch (error) {\n      throw ErrorHandler.createError(\n        'Failed to store tokens',\n        'NETWORK_ERROR',\n        error instanceof Error ? error : new Error(String(error))\n      );\n    }\n  }\n\n  /**\n   * Get stored access token\n   */\n  async getAccessToken(): Promise<string | null> {\n    return this.storageAdapter.getItem(TokenManager.STORAGE_KEYS.ACCESS_TOKEN);\n  }\n\n  /**\n   * Get stored refresh token\n   */\n  async getRefreshToken(): Promise<string | null> {\n    return this.storageAdapter.getItem(TokenManager.STORAGE_KEYS.REFRESH_TOKEN);\n  }\n\n  /**\n   * Check if access token is expired\n   */\n  async isTokenExpired(): Promise<boolean> {\n    const expiryTimeStr = await this.storageAdapter.getItem(TokenManager.STORAGE_KEYS.TOKEN_EXPIRY);\n    \n    if (!expiryTimeStr) {\n      return false; // No expiry time stored, assume not expired\n    }\n\n    const expiryTime = parseInt(expiryTimeStr, 10);\n    return Date.now() >= expiryTime;\n  }\n\n  /**\n   * Clear all stored tokens\n   */\n  async clearTokens(): Promise<void> {\n    const keys = Object.values(TokenManager.STORAGE_KEYS);\n    await this.storageAdapter.removeItems(keys);\n  }\n\n  /**\n   * Revoke tokens\n   */\n  async revokeTokens(config: OAuthConfig): Promise<void> {\n    try {\n      const accessToken = await this.getAccessToken();\n      \n      if (accessToken) {\n        await this.httpAdapter.post(\n          config.endpoints.revocation,\n          { token: accessToken, client_id: config.clientId },\n          { 'Content-Type': 'application/x-www-form-urlencoded' }\n        );\n      }\n\n      await this.clearTokens();\n    } catch (error) {\n      // Log error but don't throw - token revocation failure shouldn't prevent logout\n      console.warn('Token revocation failed:', error);\n      await this.clearTokens();\n    }\n  }\n}\n"
        }
    ]
}