{
    "sourceFile": "src/core/OAuthCore.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1752827351687,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752827407166,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,13 +5,14 @@\n import { FlowRegistry } from './FlowRegistry';\n import { PKCEManager } from './PKCEManager';\n import { TokenManager } from './TokenManager';\n import { StateValidator } from './StateValidator';\n-import { \n-  OAuthConfig, \n-  OAuthAdapters, \n-  OAuthResult, \n-  FlowConfiguration \n+import {\n+  OAuthConfig,\n+  OAuthAdapters,\n+  OAuthResult,\n+  FlowConfiguration,\n+  OAUTH_ERROR_CODES\n } from '../types/OAuthTypes';\n import { FlowHandler } from '../types/FlowTypes';\n import { ErrorHandler } from '../utils/ErrorHandler';\n import { UrlParser } from '../utils/UrlParser';\n"
                },
                {
                    "date": 1752827450498,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -143,9 +143,9 @@\n     \n     if (!refreshToken) {\n       throw ErrorHandler.createError(\n         'No refresh token available',\n-        'MISSING_REQUIRED_PARAMETER'\n+        OAUTH_ERROR_CODES.MISSING_REQUIRED_PARAMETER\n       );\n     }\n \n     return this.tokenManager.refreshToken(refreshToken, this.config);\n"
                },
                {
                    "date": 1752832070511,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -15,9 +15,9 @@\n } from '../types/OAuthTypes';\n import { FlowHandler } from '../types/FlowTypes';\n import { ErrorHandler } from '../utils/ErrorHandler';\n import { UrlParser } from '../utils/UrlParser';\n-import { createBuiltInFlowHandlers } from '../flows';\n+import { AuthorizationCodeFlowHandler, MagicLinkFlowHandler } from '../flows';\n \n export class OAuthCore {\n   private flowRegistry: FlowRegistry;\n   private pkceManager: PKCEManager;\n"
                },
                {
                    "date": 1752832099200,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -193,10 +193,13 @@\n    * Initialize flow handlers based on configuration\n    */\n   private initializeFlows(flowConfig?: FlowConfiguration): void {\n     // Register built-in flows first\n-    const builtInHandlers = createBuiltInFlowHandlers();\n-    \n+    const builtInHandlers = [\n+      new AuthorizationCodeFlowHandler(),\n+      new MagicLinkFlowHandler(),\n+    ];\n+\n     for (const handler of builtInHandlers) {\n       // Only register if not explicitly disabled\n       if (!flowConfig?.disabledFlows?.includes(handler.name)) {\n         this.flowRegistry.register(handler);\n"
                }
            ],
            "date": 1752827351687,
            "name": "Commit-0",
            "content": "/**\n * Main OAuth orchestrator\n */\n\nimport { FlowRegistry } from './FlowRegistry';\nimport { PKCEManager } from './PKCEManager';\nimport { TokenManager } from './TokenManager';\nimport { StateValidator } from './StateValidator';\nimport { \n  OAuthConfig, \n  OAuthAdapters, \n  OAuthResult, \n  FlowConfiguration \n} from '../types/OAuthTypes';\nimport { FlowHandler } from '../types/FlowTypes';\nimport { ErrorHandler } from '../utils/ErrorHandler';\nimport { UrlParser } from '../utils/UrlParser';\nimport { createBuiltInFlowHandlers } from '../flows';\n\nexport class OAuthCore {\n  private flowRegistry: FlowRegistry;\n  private pkceManager: PKCEManager;\n  private tokenManager: TokenManager;\n  private stateValidator: StateValidator;\n\n  constructor(\n    private config: OAuthConfig,\n    private adapters: OAuthAdapters,\n    flowConfig?: FlowConfiguration\n  ) {\n    this.flowRegistry = new FlowRegistry();\n    this.pkceManager = new PKCEManager(adapters.pkce, adapters.storage);\n    this.tokenManager = new TokenManager(adapters.http, adapters.storage);\n    this.stateValidator = new StateValidator(adapters.storage);\n\n    this.initializeFlows(flowConfig);\n  }\n\n  /**\n   * Handle OAuth callback with automatic flow detection\n   */\n  async handleCallback(params: URLSearchParams | string, explicitFlow?: string): Promise<OAuthResult> {\n    try {\n      // Parse parameters if string provided\n      const urlParams = typeof params === 'string' ? UrlParser.parseParams(params) : params;\n\n      // Log callback attempt (with sanitized parameters)\n      console.log('[OAuthCore] Handling callback:', UrlParser.sanitizeForLogging(urlParams));\n\n      let handler: FlowHandler | undefined;\n\n      // Try explicit flow first if specified\n      if (explicitFlow) {\n        handler = this.flowRegistry.getHandler(explicitFlow);\n        if (!handler) {\n          throw ErrorHandler.handleUnknownFlow(explicitFlow);\n        }\n      } else {\n        // Auto-detect flow using registered handlers\n        handler = this.flowRegistry.detectFlow(urlParams, this.config);\n      }\n\n      if (!handler) {\n        throw ErrorHandler.handleNoFlowHandler();\n      }\n\n      console.log(`[OAuthCore] Using flow handler: ${handler.name}`);\n\n      // Validate if handler supports validation\n      if (handler.validate && !(await handler.validate(urlParams, this.config))) {\n        throw ErrorHandler.handleFlowValidationFailed(handler.name);\n      }\n\n      // Handle the flow\n      const result = await handler.handle(urlParams, this.adapters, this.config);\n\n      console.log(`[OAuthCore] Flow ${handler.name} completed:`, {\n        success: result.success,\n        hasAccessToken: !!result.accessToken,\n        hasRefreshToken: !!result.refreshToken,\n      });\n\n      return result;\n\n    } catch (error) {\n      console.error('[OAuthCore] Callback handling failed:', ErrorHandler.formatError(error));\n      \n      if (ErrorHandler.isOAuthError(error)) {\n        throw error;\n      }\n\n      throw ErrorHandler.createError(\n        `OAuth callback handling failed: ${error instanceof Error ? error.message : String(error)}`,\n        OAUTH_ERROR_CODES.TOKEN_EXCHANGE_FAILED,\n        error instanceof Error ? error : undefined\n      );\n    }\n  }\n\n  /**\n   * Generate PKCE challenge for authorization request\n   */\n  async generatePKCEChallenge() {\n    return this.pkceManager.generateChallenge();\n  }\n\n  /**\n   * Generate OAuth state parameter\n   */\n  async generateState(): Promise<string> {\n    const state = await this.pkceManager.generateState();\n    await this.stateValidator.storeState(state);\n    return state;\n  }\n\n  /**\n   * Get current access token\n   */\n  async getAccessToken(): Promise<string | null> {\n    return this.tokenManager.getAccessToken();\n  }\n\n  /**\n   * Get current refresh token\n   */\n  async getRefreshToken(): Promise<string | null> {\n    return this.tokenManager.getRefreshToken();\n  }\n\n  /**\n   * Check if current token is expired\n   */\n  async isTokenExpired(): Promise<boolean> {\n    return this.tokenManager.isTokenExpired();\n  }\n\n  /**\n   * Refresh access token using refresh token\n   */\n  async refreshAccessToken(): Promise<OAuthResult> {\n    const refreshToken = await this.tokenManager.getRefreshToken();\n    \n    if (!refreshToken) {\n      throw ErrorHandler.createError(\n        'No refresh token available',\n        'MISSING_REQUIRED_PARAMETER'\n      );\n    }\n\n    return this.tokenManager.refreshToken(refreshToken, this.config);\n  }\n\n  /**\n   * Revoke tokens and clear storage\n   */\n  async logout(): Promise<void> {\n    await this.tokenManager.revokeTokens(this.config);\n    await this.pkceManager.clearPKCEData();\n    await this.stateValidator.clearState();\n  }\n\n  /**\n   * Register a custom flow handler\n   */\n  registerFlow(handler: FlowHandler): void {\n    this.flowRegistry.register(handler);\n  }\n\n  /**\n   * Unregister a flow handler\n   */\n  unregisterFlow(name: string): void {\n    this.flowRegistry.unregister(name);\n  }\n\n  /**\n   * Get all registered flow handlers\n   */\n  getRegisteredFlows(): FlowHandler[] {\n    return this.flowRegistry.getAllHandlers();\n  }\n\n  /**\n   * Get compatible handlers for given parameters\n   */\n  getCompatibleHandlers(params: URLSearchParams | string): FlowHandler[] {\n    const urlParams = typeof params === 'string' ? UrlParser.parseParams(params) : params;\n    return this.flowRegistry.getCompatibleHandlers(urlParams, this.config);\n  }\n\n  /**\n   * Initialize flow handlers based on configuration\n   */\n  private initializeFlows(flowConfig?: FlowConfiguration): void {\n    // Register built-in flows first\n    const builtInHandlers = createBuiltInFlowHandlers();\n    \n    for (const handler of builtInHandlers) {\n      // Only register if not explicitly disabled\n      if (!flowConfig?.disabledFlows?.includes(handler.name)) {\n        this.flowRegistry.register(handler);\n      }\n    }\n\n    // Register custom flows if provided\n    if (flowConfig?.customFlows) {\n      for (const handler of flowConfig.customFlows) {\n        this.flowRegistry.register(handler);\n      }\n    }\n\n    // If enabledFlows is specified, remove all others\n    if (flowConfig?.enabledFlows) {\n      const allHandlers = this.flowRegistry.getAllHandlers();\n      \n      for (const handler of allHandlers) {\n        if (!flowConfig.enabledFlows.includes(handler.name)) {\n          this.flowRegistry.unregister(handler.name);\n        }\n      }\n    }\n\n    // Validate that we have at least one flow handler\n    if (this.flowRegistry.getHandlerCount() === 0) {\n      throw ErrorHandler.handleInvalidConfiguration(\n        'No flow handlers registered. At least one flow handler is required.'\n      );\n    }\n\n    console.log('[OAuthCore] Initialized with flows:', this.flowRegistry.getHandlerNames());\n  }\n}\n"
        }
    ]
}